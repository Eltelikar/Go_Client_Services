package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"client-services/internal/graph/model"
	"context"
	"fmt"
	"log/slog"
	"strings"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, commentsAllowed bool) (*model.Post, error) {
	const op = "graph.schema.resolvers.CreatePost"

	if strings.TrimSpace(title) == "" {
		r.Log.Debug("user tries create post with empty title")
		return nil, fmt.Errorf("title cannot be empty")
	}
	if strings.TrimSpace(content) == "" {
		r.Log.Debug("user tries create post with empty content")
		return nil, fmt.Errorf("content cannot be empty")
	}

	post := &model.Post{
		Title:           title,
		Content:         content,
		CommentsAllowed: commentsAllowed,
	}

	id, time, err := r.Post_.SavePost(ctx, post)
	if err != nil {
		r.Log.Error("failed to save post",
			slog.String("op", op),
			slog.String("error", err.Error()),
		)
		return nil, fmt.Errorf("%s: failed to save post: %w", op, err)
	}

	post.ID = id
	post.CreatedAt = time

	r.Log.Info("post successfully saved",
		slog.String("postID", id),
	)
	return post, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, parentID *string, postID string, content string) (*model.Comment, error) {
	const op = "graph.schema.resolvers.CreateComment"
	if len(content) > 2000 {
		r.Log.Error("text must have 2000 chars or less",
			slog.String("op", op))
		return nil, fmt.Errorf("%s: text must have 2000 chars or less", op)
	}

	if strings.TrimSpace(content) == "" {
		return nil, fmt.Errorf("content cannot be empty")
	}

	post, err := r.Post_.GetPost(ctx, postID)
	if err != nil {
		if strings.Contains(err.Error(), "post not found") {
			r.Log.Info("user trying to create comment to not existing post",
				slog.String("op", op),
				slog.String("error", err.Error()))
			return nil, fmt.Errorf("%s: trying to create comment to not existing post: %w", op, err)
		}
		r.Log.Error("failed to get post for comment",
			slog.String("op", op),
			slog.String("error", err.Error()),
		)
		return nil, fmt.Errorf("%s: failed to get post for comment: %w", op, err)
	}

	m := r.UqMutex.GetMutex(postID)
	m.RLock()
	defer m.RUnlock()
	if !post.CommentsAllowed {
		r.Log.Info("user trying to create comment to post that not allowed comments",
			slog.String("op", op))
		return nil, fmt.Errorf("%s: this post not allow comments", op)
	}

	insertParent := false
	if parentID != nil {
		err = r.Comment_.IsCommentExist(ctx, *parentID, postID)
		if err != nil {
			if strings.Contains(err.Error(), "not found") {
				r.Log.Info("parrent comment not found",
					slog.String("op", op),
					slog.String("commentID", *parentID),
				)
				return nil, fmt.Errorf("%s: parrent comment not found: %w", op, err)
			}
			if strings.Contains(err.Error(), "this comment from another post") {
				r.Log.Info("parrent comment from another post",
					slog.String("op", op),
					slog.String("commentID", *parentID),
				)
				return nil, fmt.Errorf("%s: parrent comment from another post: %w", op, err)
			}

			r.Log.Info("failed to find parent comment",
				slog.String("op", op),
				slog.String("commentID", *parentID),
				slog.String("error", err.Error()),
			)
			return nil, fmt.Errorf("%s: failed to find parent comment: %w", op, err)
		}

		insertParent = true
	}

	comment := &model.Comment{
		PostID:  postID,
		Content: content,
	}
	if insertParent {
		comment.ParentID = parentID
	}

	id, time, err := r.Comment_.SaveComment(ctx, comment)
	if err != nil {
		r.Log.Error("failed to save comment",
			slog.String("op", op),
			slog.String("error", err.Error()),
		)
		return nil, fmt.Errorf("%s: failed to save comment: %w", op, err)
	}

	comment.ID = id
	comment.CreatedAt = time

	go func() {
		r.CommentAdded <- &model.CommentNotify{PostID: postID, ID: comment.ID, Content: comment.Content}
	}()
	r.Log.Info("comment successfully saved",
		slog.String("commentID", id),
		slog.String("postID", postID),
	)
	return comment, nil
}

// GetAllPosts is the resolver for the getAllPosts field.
func (r *queryResolver) GetAllPosts(ctx context.Context) ([]*model.Post, error) {
	const op = "graph.schema.resolvers.GetAllPosts"

	posts, err := r.Post_.GetAllPosts(ctx)
	if err != nil {
		r.Log.Error("failed to get posts", slog.String("op", op), slog.String("error", err.Error()))
		return nil, fmt.Errorf("%s: failed to get posts: %w", op, err)
	}

	var result []*model.Post
	for i := range posts {
		result = append(result, &posts[i])
	}
	r.Log.Info("posts was get successfully")
	return result, nil
}

// GetPost is the resolver for the getPost field.
func (r *queryResolver) GetPost(ctx context.Context, id string, first *int32, after *string) (*model.Post, error) {
	const op = "graph.schema.resolvers.GetPost"

	if first == nil {
		return nil, fmt.Errorf("%s: parameter `first` is missing", op)
	} else if *first < 0 {
		return nil, fmt.Errorf("%s: `first` cannot be less than 0", op)
	}

	post, err := r.Post_.GetPost(ctx, id)
	if err != nil {
		r.Log.Error("failed to get post",
			slog.String("op", op),
			slog.String("error", err.Error()),
		)
		return nil, fmt.Errorf("%s: failed to get post: %w", op, err)
	}

	m := r.UqMutex.GetMutex(id)
	m.RLock()
	defer m.RUnlock()
	if after != nil {
		err = r.Comment_.IsCommentExist(ctx, *after, id)
		if err != nil {
			r.Log.Info("failed to find cursor",
				slog.String("op", op),
				slog.String("cursor", *after),
				slog.String("error", err.Error()),
			)
			return nil, fmt.Errorf("%s: failed to find cursor: %w", op, err)
		}
	}

	comments, hasNextPage, newCursor, err := r.Comment_.GetComments(ctx, first, after, id)
	if err != nil {
		r.Log.Error("failed to get comments",
			slog.String("op", op),
			slog.String("postID", id),
			slog.String("error", err.Error()),
		)
		return nil, fmt.Errorf("%s: failed to get comments: %w", op, err)
	}

	pInfo := &model.PageInfo{
		EndCursor:   &newCursor,
		HasNextPage: hasNextPage,
	}

	var comEdges []*model.CommentEdge
	for _, com := range *comments {
		cursor := com.ID
		node := &model.Comment{
			ID:        com.ID,
			PostID:    com.PostID,
			ParentID:  com.ParentID,
			Content:   com.Content,
			CreatedAt: com.CreatedAt,
		}
		comEdges = append(comEdges,
			&model.CommentEdge{
				Cursor: cursor,
				Node:   node,
			})
	}

	comConnection := &model.CommentConnection{
		Edges:    comEdges,
		PageInfo: pInfo,
	}

	post.Comments = comConnection

	r.Log.Info("post was get successfully",
		slog.String("postID", id),
	)

	return post, nil
}

// CommentsUpdated is the resolver for the commentsUpdated field.
func (r *subscriptionResolver) CommentsUpdated(ctx context.Context, postID string) (<-chan *model.CommentNotify, error) {
	const op = "graph.schema.resolvers.CommentsUpdated"

	r.Log.Info("%s: new subscription - %s", op, postID)

	clientChannel := make(chan *model.CommentNotify, 1)
	go func() {
		defer close(clientChannel)
		defer r.Log.Info("%s: subscription closed - %s", op, postID)

		for {
			select {
			case <-ctx.Done():
				return
			case notify := <-r.CommentAdded:
				if notify.PostID == postID {
					r.Log.Debug("%s: try to send notify: %s", op, postID)
					select {
					case clientChannel <- notify:
						r.Log.Debug("%s: notify sended: %s", op, postID)
					case <-ctx.Done():
						return
					}
				} else {
				}
			}
		}
	}()

	return clientChannel, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
