package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"client-services/internal/graph/model"
	"context"
	"fmt"
	"log/slog"
	"strings"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, commentsAllowed bool) (*model.Post, error) {
	const op = "graph.schema.resolvers.CreatePost"

	post := &model.Post{
		Title:           title,
		Content:         content,
		CommentsAllowed: commentsAllowed,
	}

	id, time, err := r.Post_.SavePost(ctx, post)
	if err != nil {
		r.Log.Error("failed to save post",
			slog.String("op", op),
			slog.String("error", err.Error()),
		)
		return nil, fmt.Errorf("%s: failed to save post: %w", op, err)
	}

	post.ID = id
	post.CreatedAt = time

	r.Log.Info("post successfully saved",
		slog.String("postID", id),
	)
	return post, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, parentID *string, postID string, content string) (*model.Comment, error) {
	const op = "graph.schema.resolvers.CreateComment"
	if len(content) > 2000 {
		r.Log.Error("text must contains 2000 chars or less",
			slog.String("op", op))
		return nil, fmt.Errorf("%s: text must contains 2000 chars or less", op)
	}

	post, err := r.Post_.GetPost(ctx, postID)
	if err != nil {
		if strings.Contains(err.Error(), "post not found") {
			r.Log.Info("user trying to create comment to not existing post",
				slog.String("op", op),
				slog.String("error", err.Error()))
			return nil, fmt.Errorf("%s: trying to create comment to not existing post: %w", op, err)
		}
		r.Log.Error("failed to get post for comment",
			slog.String("op", op),
			slog.String("error", err.Error()),
		)
		return nil, fmt.Errorf("%s: failed to get post for comment: %w", op, err)
	}

	r.Mu.Lock()
	defer r.Mu.Unlock()
	if !post.CommentsAllowed {
		r.Log.Info("user trying to create comment to post that not allowed comments",
			slog.String("op", op))
		return nil, fmt.Errorf("%s: this post not allow comments", op)
	}

	insertParent := false
	if parentID != nil {
		err = r.Comment_.IsCommentExist(ctx, *parentID, postID)
		if err != nil {
			if strings.Contains(err.Error(), "not found") {
				r.Log.Info("parrent comment not found",
					slog.String("op", op),
					slog.String("commentID", *parentID),
				)
				return nil, fmt.Errorf("%s: parrent comment not found: %w", op, err)
			}
			if strings.Contains(err.Error(), "this comment from another post") {
				r.Log.Info("parrent comment from another post",
					slog.String("op", op),
					slog.String("commentID", *parentID),
					slog.String("parentPost", postID),
				)
				return nil, fmt.Errorf("%s: parrent comment from another post with id - %s: %w", op, postID, err)
			}

			r.Log.Info("failed to find parent comment",
				slog.String("op", op),
				slog.String("commentID", *parentID),
				slog.String("error", err.Error()),
			)
			return nil, fmt.Errorf("%s: failed to find parent comment: %w", op, err)
		}

		insertParent = true
	}

	comment := &model.Comment{
		PostID:  postID,
		Content: content,
	}
	if insertParent {
		comment.ParentID = parentID
	}

	id, time, err := r.Comment_.SaveComment(ctx, comment)
	if err != nil {
		r.Log.Error("failed to save comment",
			slog.String("op", op),
			slog.String("error", err.Error()),
		)
		return nil, fmt.Errorf("%s: failed to save comment: %w", op, err)
	}

	comment.ID = id
	comment.CreatedAt = time

	r.Log.Info("comment successfully saved",
		slog.String("commentID", id),
		slog.String("postID", postID),
	)
	return comment, nil
}

// GetAllPosts is the resolver for the getAllPosts field.
func (r *queryResolver) GetAllPosts(ctx context.Context) ([]*model.Post, error) {
	const op = "graph.schema.resolvers.GetAllPosts"

	r.Mu.RLock()
	defer r.Mu.RUnlock()

	posts, err := r.Post_.GetAllPosts(ctx)
	if err != nil {
		r.Log.Error("failed to get posts", slog.String("op", op), slog.String("error", err.Error()))
		return nil, fmt.Errorf("%s: failed to get posts: %w", op, err)
	}

	var result []*model.Post
	for i := range posts {
		result = append(result, &posts[i])
	}

	return result, nil
}

// GetPost is the resolver for the getPost field.
func (r *queryResolver) GetPost(ctx context.Context, id string, first *int32, after *string) (*model.Post, error) {
	const op = "graph.schema.resolvers.GetPost"

	if first == nil {
		return nil, fmt.Errorf("%s: parameter `first` is missing", op)
	}
	post, err := r.Post_.GetPost(ctx, id)
	if err != nil {
		r.Log.Error("failed to get post",
			slog.String("op", op),
			slog.String("error", err.Error()),
		)
		return nil, fmt.Errorf("%s: failed to get post: %w", op, err)
	}

	r.Mu.RLock()
	defer r.Mu.RUnlock()
	if after != nil {
		err = r.Comment_.IsCommentExist(ctx, *after, id)
		if err != nil {
			r.Log.Info("failed to find cursor",
				slog.String("op", op),
				slog.String("cursor", *after),
				slog.String("error", err.Error()),
			)
			return nil, fmt.Errorf("%s: failed to find cursor: %w", op, err)
		}
	}

	comments, hasNextPage, newCursor, err := r.Comment_.GetComments(ctx, first, after, id)
	if err != nil {
		r.Log.Error("failed to get comments",
			slog.String("op", op),
			slog.String("postID", id),
			slog.String("error", err.Error()),
		)
		return nil, fmt.Errorf("%s: failed to get comments: %w", op, err)
	}

	pInfo := &model.PageInfo{
		EndCursor:   &newCursor,
		HasNextPage: hasNextPage,
	}

	var comEdges []*model.CommentEdge
	for _, com := range *comments {
		cursor := com.ID
		node := &model.Comment{
			ID:        com.ID,
			PostID:    com.PostID,
			ParentID:  com.ParentID,
			Content:   com.Content,
			CreatedAt: com.CreatedAt,
		}
		comEdges = append(comEdges,
			&model.CommentEdge{
				Cursor: cursor,
				Node:   node,
			})
	}

	comConnection := &model.CommentConnection{
		Edges:    comEdges,
		PageInfo: pInfo,
	}

	post.Comments = comConnection

	r.Log.Info("post was get successfully",
		slog.String("postID", id),
	)

	return post, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
